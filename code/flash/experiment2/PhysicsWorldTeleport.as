package{	import Box2D.Collision.Shapes.b2CircleShape;	import Box2D.Collision.Shapes.b2PolygonShape;	import Box2D.Collision.Shapes.b2Shape;	import Box2D.Common.*;	import Box2D.Common.Math.*;	import Box2D.Dynamics.*;	import Box2D.Dynamics.Contacts.*;	import Box2D.Dynamics.Joints.*;	import Box2D.Dynamics.b2Body;	import Box2D.Dynamics.b2BodyDef;	import Box2D.Dynamics.b2ContactListener;	import Box2D.Dynamics.b2DebugDraw;	import Box2D.Dynamics.b2Fixture;	import Box2D.Dynamics.b2FixtureDef;	import Box2D.Dynamics.b2World;		import flash.display.InteractiveObject;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.Event;	import flash.net.*;	import flash.utils.getTimer;	public class PhysicsWorldTeleport extends Sprite	{		// public var collision:Array = [44,	57,	25,	41,	68,	72,	41,	36,	54,	42,	73,	71,	66,	58,	60,	45,	96,	49,	38,	58,	53,	124, 52, 52, 38, 59, 54, 58, 60]; 					public function PhysicsWorldTeleport(flashPattern:uint, condition:uint, collision:Number, startClip:Number, stopClip:Number, saveData_bol:Boolean, teleport_bol:Boolean, teleportActive_bol:Boolean, brick_bol:Boolean, grass_bol:Boolean, angularNoise:Number, velocityNoise:Number, ffRate:Number, fixedNoise_bol:Boolean,  mirror_int:int, simulation_bol:Boolean) 		{					 									//variables needed for simulation			var run:int = 1;			var maxRun:int = 2;			var counter:int = 0;			var maxPattern:int = 20;			var nSimulations:int = 1000;			var timer:int = startClip;			var goalReached:int = 0; 			var data:Array = new Array();			var ffRate:Number; 			//physics variables			var flashPattern:uint;			var condition:uint; 			var collision:Number; 			var startClip:Number; 			var stopClip:Number; 			var saveData_bol:Boolean; 			var teleport_bol:Boolean; 			var brick_bol:Boolean = true; 			var grass_bol:Boolean = false; 			var angularNoise:Number; 			var velocityNoise:Number; 						var fixedNoise_bol:Boolean; 			var simulation_bol:Boolean;			var collision_ary:Array = [98,99,109,107,98,99,117,119,114,109,114,119,113,65,158,104,113,65,98,61,0,0,0,0]; //three last 0 added for the cases which were used in the single, preemption, and overdetermination experiment					var mirror_int:int;			//event listeners for control flow (otherwise, functioning is stochastic)			addEventListener("NewRound",RunPhysics);			addEventListener("SimulationRoundFinished",SaveData);						dispatchEvent(new Event("NewRound"));				function RunPhysics(event:Event){													//Scaling constant 			var SCALE:Number = 60; //--> pixel to meter 			var WIDTH:Number = 800;			var HEIGHT:Number = 600;			var speed:Number = 3;								//Creating the world			var gravity:b2Vec2 = new b2Vec2(0,0); //x and y coordinate			var allowSleep:Boolean = false;			var world:b2World = new b2World(gravity,allowSleep);						//Balls			var body1posx:Number;				var body1posy:Number;			var body1linx:Number;			var body1liny:Number;						var body2posx:Number; 			var body2posy:Number;			var body2linx:Number;			var body2liny:Number;			//Brick			var brickX:Number;			var brickY:Number;			var brickRotation:Number; //= 0;			//var brick_bol:Boolean = false;						//Grass			var grassX:Number;			var grassY:Number;			var grassRadius:Number;						var grass_bol:Boolean = false;						//Teleport gate 			var teleportX:Number;			var teleportY:Number;			var teleportRotation:Number; //= 0;			var teleport_bol:Boolean;			var teleportActive_bol:Boolean;						//Teleport gate 			var exitX:Number;			var exitY:Number;									//////////////////////////////////////////////////////			// Create Objects				//////////////////////////////////////////////////////						//Creating Objects in the world  			//1. Body definition			//2. Body			//3. Shape 			//4. Fixture definition 			//5. Create fixture 								//Walls						var topWallBody:b2Body = createWalls((WIDTH/2)/SCALE,10/SCALE, (WIDTH/2)/SCALE,(20/2)/SCALE,"topWall");			var bottomWallBody:b2Body = createWalls((WIDTH/2)/SCALE,590/SCALE, (WIDTH/2)/SCALE,(20/2)/SCALE,"bottomWall");			var topLeftWallBody:b2Body = createWalls(10/SCALE,100/SCALE, 10/SCALE,100/SCALE,"topLeftWall");			var bottomLeftWallBody:b2Body = createWalls(10/SCALE,(HEIGHT-100)/SCALE, 10/SCALE,100/SCALE,"bottomLeftWall");						function createWalls(positionX,positionY,halfwidth,halfheight,userdata):b2Body{				//def				var wallBodyDef:b2BodyDef = new b2BodyDef();				wallBodyDef.position.Set(positionX,positionY); //position of the body				wallBodyDef.type = b2Body.b2_staticBody; //determines the body type					var wallBody:b2Body = world.CreateBody(wallBodyDef); //adds the body to the world				//shape				var wallShape:b2PolygonShape = new b2PolygonShape(); //box shape 				wallShape.SetAsBox(halfwidth,halfheight);				//fixture 				var wallFixtureDef:b2FixtureDef = new b2FixtureDef();				wallFixtureDef.shape = wallShape;				wallFixtureDef.density = 1;				wallFixtureDef.friction = 0;				wallFixtureDef.restitution = 1;				wallBody.SetUserData(userdata);				wallBody.CreateFixture(wallFixtureDef); //assign fixture definition to the body				return wallBody;			}							patterns_func();			function patterns_func(){			//Patterns				switch (flashPattern)				{										case 1: 					body1posx = (WIDTH + 30)/SCALE; 					body1posy = (310)/SCALE;					body1linx = speed*-0.9;					body1liny = speed*0;										body2posx = (WIDTH+30)/SCALE;					body2posy = (60)/SCALE;					body2linx = speed*-0.9;					body2liny = speed*0.5;															brickX = 300/SCALE;					brickY = 290/SCALE;					brickRotation = 0;					brick_bol = true;					teleport_bol = false;					break;										case 2: 					body1posx = (WIDTH + 30)/SCALE; 					body1posy = (550)/SCALE;					body1linx = speed*-1;					body1liny = speed*-.55;										body2posx = (WIDTH+50)/SCALE;					body2posy = (50)/SCALE;					body2linx = speed*-1;					body2liny = speed*.6;															brick_bol = false;															teleportX = 220/SCALE;					teleportY = 190/SCALE;					teleportRotation = 45;					teleport_bol = true;					teleportActive_bol = false;										exitX = 50;					exitY = 350;					break;										case 3: 					body1posx = (WIDTH + 30)/SCALE; 					body1posy = (550)/SCALE;					body1linx = speed*-1;					body1liny = speed*-.4;										body2posx = (WIDTH+50)/SCALE;					body2posy = (50)/SCALE;					body2linx = speed*-1;					body2liny = speed*.65;															brick_bol = false;															teleportX = 200/SCALE;					teleportY = 450/SCALE;					teleportRotation = 135;					teleport_bol = true;					teleportActive_bol = false;										exitX = 70;					exitY = 250;					break;										case 4: 					body1posx = (WIDTH + 30)/SCALE; 					body1posy = (550)/SCALE;					body1linx = speed*-1;					body1liny = speed*-.42;										body2posx = (WIDTH+50)/SCALE;					body2posy = (50)/SCALE;					body2linx = speed*-1;					body2liny = speed*.65;															brick_bol = false;															teleportX = 200/SCALE;					teleportY = 450/SCALE;					teleportRotation = 135;					teleport_bol = true;					teleportActive_bol = true;										exitX = 70;					exitY = 70;					break;										case 5: 					body1posx = (WIDTH + 30)/SCALE; 					body1posy = (310)/SCALE;					body1linx = speed*-0.9;					body1liny = speed*0;										body2posx = (WIDTH+30)/SCALE;					body2posy = (60)/SCALE;					body2linx = speed*-0.9;					body2liny = speed*0.5;															brickX = 300/SCALE;					brickY = 195/SCALE;					brickRotation = 0;					brick_bol = true;					teleport_bol = false;															break;										case 6: 					body1posx = (WIDTH + 30)/SCALE; 					body1posy = (550)/SCALE;					body1linx = speed*-1;					body1liny = speed*-.55;										body2posx = (WIDTH+50)/SCALE;					body2posy = (50)/SCALE;					body2linx = speed*-1;					body2liny = speed*.6;															brick_bol = false;															teleportX = 220/SCALE;					teleportY = 190/SCALE;					teleportRotation = 45;					teleport_bol = true;					teleportActive_bol = true;										exitX = 50;					exitY = 350;					break;										case 7: 					body1posx = (WIDTH + 30)/SCALE; 					body1posy = (550)/SCALE;					body1linx = speed*-1;					body1liny = speed*-.55;										body2posx = (WIDTH+50)/SCALE;					body2posy = (50)/SCALE;					body2linx = speed*-1;					body2liny = speed*.43;															brick_bol = false;															teleportX = 220/SCALE;					teleportY = 190/SCALE;					teleportRotation = 45;					teleport_bol = true;					teleportActive_bol = false;										exitX = 50;					exitY = 350;					break;						case 8: 					body1posx = (WIDTH + 30)/SCALE; 					body1posy = (550)/SCALE;					body1linx = speed*-1;					body1liny = speed*-.55;										body2posx = (WIDTH+50)/SCALE;					body2posy = (50)/SCALE;					body2linx = speed*-1;					body2liny = speed*.41;															brick_bol = false;															teleportX = 220/SCALE;					teleportY = 190/SCALE;					teleportRotation = 45;					teleport_bol = true;					teleportActive_bol = false;										exitX = 50;					exitY = 350;					break;										case 9:					body1posx = (WIDTH + 30)/SCALE; 					body1posy = (550)/SCALE;					body1linx = speed*-1;					body1liny = speed*-.4;										body2posx = (WIDTH+50)/SCALE;					body2posy = (50)/SCALE;					body2linx = speed*-1;					body2liny = speed*.6;															brick_bol = false;															teleportX = 170/SCALE;					teleportY = 480/SCALE;					teleportRotation = 135;					teleport_bol = true;					teleportActive_bol = true;										exitX = 150;					exitY = 340;					break;					case 10: 					body1posx = (WIDTH + 30)/SCALE; 					body1posy = (550)/SCALE;					body1linx = speed*-1;					body1liny = speed*-.45;										body2posx = (WIDTH+50)/SCALE;					body2posy = (50)/SCALE;					body2linx = speed*-1;					body2liny = speed*.6;															brick_bol = false;															teleportX = 170/SCALE;					teleportY = 480/SCALE;					teleportRotation = 135;					teleport_bol = true;					teleportActive_bol = true;										exitX = 150;					exitY = 330;					break;										case 11: 					body1posx = (WIDTH + 30)/SCALE; 					body1posy = (550)/SCALE;					body1linx = speed*-1;					body1liny = speed*-.55;										body2posx = (WIDTH+50)/SCALE;					body2posy = (50)/SCALE;					body2linx = speed*-1;					body2liny = speed*.45;															brick_bol = false;															teleportX = 220/SCALE;					teleportY = 190/SCALE;					teleportRotation = 45;					teleport_bol = true;					teleportActive_bol = true;										exitX = 50;					exitY = 350;					break;										case 12:					body1posx = (WIDTH + 30)/SCALE; 					body1posy = (550)/SCALE;					body1linx = speed*-1;					body1liny = speed*-.55;										body2posx = (WIDTH+50)/SCALE;					body2posy = (50)/SCALE;					body2linx = speed*-1;					body2liny = speed*.41;															brick_bol = false;															teleportX = 220/SCALE;					teleportY = 190/SCALE;					teleportRotation = 45;					teleport_bol = true;					teleportActive_bol = true;										exitX = 50;					exitY = 350;					break;															case 13: 					body1posx = (WIDTH + 30)/SCALE; 					body1posy = (550)/SCALE;					body1linx = speed*-1;					body1liny = speed*-.55;										body2posx = (WIDTH+75)/SCALE;					body2posy = (50)/SCALE;					body2linx = speed*-1;					body2liny = speed*.5;															brick_bol = false;															teleportX = 220/SCALE;					teleportY = 190/SCALE;					teleportRotation = 45;					teleport_bol = true;					teleportActive_bol = false;										exitX = 50;					exitY = 350;					break;										case 14: 					body1posx = (WIDTH + 30)/SCALE; 					body1posy = (310)/SCALE;					body1linx = speed*-0.9;					body1liny = speed*0;										body2posx = (WIDTH+30)/SCALE;					body2posy = (60)/SCALE;					body2linx = speed*-0.9;					body2liny = speed*0.75;										brick_bol = true;										brickX = 300/SCALE;					brickY = 290/SCALE;					brickRotation = 0;															teleportActive_bol = false;										break;										case 15: 					body1posx = (WIDTH + 30)/SCALE; 					body1posy = (550)/SCALE;					body1linx = speed*-1;					body1liny = speed*-.4;										body2posx = (WIDTH+50)/SCALE;					body2posy = (50)/SCALE;					body2linx = speed*-1;					body2liny = speed*.33;															brick_bol = false;															teleportX = 200/SCALE;					teleportY = 450/SCALE;					teleportRotation = 135;					teleportActive_bol = false;					teleport_bol = true;										exitX = 70;					exitY = 250;					break;										case 16: 					body1posx = (WIDTH + 30)/SCALE; 					body1posy = (550)/SCALE;					body1linx = speed*-1;					body1liny = speed*-.45;										body2posx = (WIDTH+50)/SCALE;					body2posy = (50)/SCALE;					body2linx = speed*-1;					body2liny = speed*.65;															brick_bol = false;															teleportX = 200/SCALE;					teleportY = 450/SCALE;					teleportRotation = 135;					teleportActive_bol = true;					teleport_bol = true;										exitX = 70;					exitY = 250;					break; 										case 17: 					body1posx = (WIDTH + 30)/SCALE; 					body1posy = (550)/SCALE;					body1linx = speed*-1;					body1liny = speed*-.55;										body2posx = (WIDTH+75)/SCALE;					body2posy = (50)/SCALE;					body2linx = speed*-1;					body2liny = speed*.5;															brick_bol = false;															teleportX = 220/SCALE;					teleportY = 190/SCALE;					teleportRotation = 45;					teleportActive_bol = true;					teleport_bol = true;										exitX = 50;					exitY = 350;					break;										case 18: 					body1posx = (WIDTH + 30)/SCALE; 					body1posy = (310)/SCALE;					body1linx = speed*-0.9;					body1liny = speed*0;										body2posx = (WIDTH+30)/SCALE;					body2posy = (60)/SCALE;					body2linx = speed*-0.9;					body2liny = speed*0.75;															brickX = 300/SCALE;					brickY = 195/SCALE;					brickRotation = 0;					brick_bol = true;															teleport_bol = false;					break;					//Practice clips 					case 19: 					body1posx = (WIDTH + 30)/SCALE; 					body1posy = (310)/SCALE;					body1linx = speed*-0.9;					body1liny = speed*0;										body2posx = (WIDTH+30)/SCALE;					body2posy = (60)/SCALE;					body2linx = speed*-0.9;					body2liny = speed*0.5;															brickX = 180/SCALE;					brickY = 200/SCALE;					brickRotation = 0;					brick_bol = true;															teleportX = 100/SCALE;					teleportY = 500/SCALE;					teleportRotation = 135;					teleportActive_bol = true;					teleport_bol = true;										exitX = 300;					exitY = 100;					break;					case 20: 					body1posx = (WIDTH + 30)/SCALE; 					body1posy = (310)/SCALE;					body1linx = speed*-0.9;					body1liny = speed*0;										body2posx = (WIDTH+30)/SCALE;					body2posy = (550)/SCALE;					body2linx = speed*-0.9;					body2liny = speed*-0.75;															brickX = 250/SCALE;					brickY = 400/SCALE;					brickRotation = 0;					brick_bol = true;															teleportX = 650/SCALE;					teleportY = 300/SCALE;					teleportRotation = 0;					teleportActive_bol = false;					teleport_bol = true;					exitX = 80;					exitY = 250;					break;						//cases used for single, preemption, and overdetermination comparison 					case 21: //single					body1posx = (WIDTH + 30)/SCALE; 					body1posy = (150)/SCALE;					body1linx = speed*-.9;					body1liny = speed*0;										body2posx = (WIDTH+400)/SCALE;					body2posy = (5)/SCALE;					body2linx = speed*-1*1.5;					body2liny = speed*.12*1.5;															brick_bol = false;															teleportX = 50/SCALE;					teleportY = 450/SCALE;					teleportRotation = 0;					teleportActive_bol = true;					teleport_bol = true;										exitX = 100;					exitY = 300;					break;					case 22: //preemption 					body1posx = (WIDTH + 30)/SCALE; 					body1posy = (150)/SCALE;					body1linx = speed*-.9;					body1liny = speed*0;										body2posx = (WIDTH+400)/SCALE;					body2posy = (5)/SCALE;					body2linx = speed*-1*1.5;					body2liny = speed*.12*1.5;															brick_bol = false;															teleportX = 50/SCALE;					teleportY = 150/SCALE;					teleportRotation = 0;					teleportActive_bol = true;					teleport_bol = true;										exitX = 100;					exitY = 300;					break;					case 23: //"overdetermination 1" (would have gone in anyway ...)					body1posx = (WIDTH + 30)/SCALE; 					body1posy = (300)/SCALE;					body1linx = speed*-.9;					body1liny = speed*0;										body2posx = (WIDTH+400)/SCALE;					body2posy = (300)/SCALE;					body2linx = speed*-1*1.5;					body2liny = speed*0;															brick_bol = false;															teleportX = 250/SCALE;					teleportY = 300/SCALE;					teleportRotation = 0;					teleportActive_bol = true;					teleport_bol = true;										exitX = 100;					exitY = 300;					break;					case 24: //"overdetermination 2" 					body1posx = (WIDTH + 30)/SCALE; 					body1posy = (150)/SCALE;					body1linx = speed*-.9;					body1liny = speed*0;										body2posx = (WIDTH+400)/SCALE;					body2posy = (150)/SCALE;					body2linx = speed*-1*1.5;					body2liny = speed*0;															brick_bol = false;															teleportX = 50/SCALE;					teleportY = 150/SCALE;					teleportRotation = 0;					teleportActive_bol = true;					teleport_bol = true;										exitX = 100;					exitY = 300;					break;				}				//vertical mirroring 				// var flip:Number = Math.random();								if (mirror_int == 1){					body1posy = HEIGHT/SCALE-body1posy;					body2posy = HEIGHT/SCALE-body2posy;					brickY = HEIGHT/SCALE-brickY;					teleportY = HEIGHT/SCALE-teleportY;					exitY = HEIGHT-exitY;					body1liny = (-1)*body1liny;					body2liny = (-1)*body2liny;					brickRotation = (-1)*brickRotation;					teleportRotation = (-1)*teleportRotation;				}				}			//get rid of grey ball for counterfactual cases			if (condition == 2){				body2posx = 1000;				body2posy = 1000;				body2linx = 0;				body2liny = 0;			}						//BALLS			var ball1Body:b2Body = createBalls(body1posx,body1posy, 1, new b2Vec2(body1linx,body1liny), 0.02,"redBall",b2Body.b2_dynamicBody);			var ball2Body:b2Body = createBalls(body2posx,body2posy, 1, new b2Vec2(body2linx,body2liny), 0.02,"greyBall",b2Body.b2_dynamicBody);						function createBalls(positionX,positionY,density,linearVel,linearDamp,userdata,type):b2Body{				//def				var ballBodyDef:b2BodyDef= new b2BodyDef();				ballBodyDef.position.Set(positionX,positionY); //position of the body				ballBodyDef.type = type; //determines the body type				ballBodyDef.bullet = true; //prevents tunelling for fast moving objects				ballBodyDef.linearVelocity = linearVel; //velocity in x and y direction (x:positive --> right, y:positive --> down)				ballBodyDef.linearDamping = linearDamp; //linear damping 				//body				var ballBody:b2Body = world.CreateBody(ballBodyDef); //adds the body to the world				//shape				var ballShape:b2CircleShape = new b2CircleShape(.5); //radius of the circle (.5 m)				//fixture 				var ballFixtureDef:b2FixtureDef = new b2FixtureDef();				ballFixtureDef.shape = ballShape;				ballFixtureDef.density = density;				ballFixtureDef.friction = 0;				ballFixtureDef.restitution = 1;								ballBody.SetUserData(userdata);				ballBody.CreateFixture(ballFixtureDef); //assign fixture definition to the body								return ballBody;			}												//GRASS			if (grass_bol == true){				grassRadius = 100;				var grassBody:b2Body = createGrass(grassX, grassY, grassRadius,"grass");							function createGrass(positionX,positionY,radius,userdata):b2Body{					var grassBodyDef:b2BodyDef = new b2BodyDef();										grassBodyDef.position.Set(positionX,positionY); //position of the body					grassBodyDef.type = b2Body.b2_staticBody; //determines the body type						var grassBody:b2Body = world.CreateBody(grassBodyDef); //adds the body to the world					//shape					var grassShape:b2CircleShape = new b2CircleShape(radius/SCALE); //circle shape 					//grassShape.SetAsBox(halfwidth,halfheight); //halfwidth,halfheight of the grass					//fixture 					var grassFixtureDef:b2FixtureDef = new b2FixtureDef();					grassFixtureDef.shape = grassShape;					grassFixtureDef.isSensor = true; //sensor shape					grassBody.SetUserData(userdata);					grassBody.CreateFixture(grassFixtureDef); //assign fixture definition to the body					return grassBody;				}			}						//BRICK 			if (brick_bol == true){				var brickBody:b2Body = createBrick(brickX, brickY, 15/SCALE,50/SCALE,"brick",brickRotation);							function createBrick(positionX,positionY,halfwidth,halfheight,userdata,rotation):b2Body{					var brickBodyDef:b2BodyDef = new b2BodyDef();										brickBodyDef.position.Set(positionX,positionY); //position of the body					brickBodyDef.angle = rotation*Math.PI/180; //rotation of the body					brickBodyDef.type = b2Body.b2_staticBody; //determines the body type						var brickBody:b2Body = world.CreateBody(brickBodyDef); //adds the body to the world					//shape					var brickShape:b2PolygonShape = new b2PolygonShape(); //box shape 					brickShape.SetAsBox(halfwidth,halfheight); //halfwidth,halfheight of the brick					//fixture 					var brickFixtureDef:b2FixtureDef = new b2FixtureDef();					brickFixtureDef.shape = brickShape;					brickFixtureDef.density = 1;					brickFixtureDef.friction = 0;					brickFixtureDef.restitution = 1;					brickBody.SetUserData(userdata);					brickBody.CreateFixture(brickFixtureDef); //assign fixture definition to the body					return brickBody;				}						}									//TELEPORT 						if (teleport_bol == true){				var teleportBody:b2Body = createTeleport(teleportX, teleportY, 15/SCALE,50/SCALE,"teleport",teleportRotation);							function createTeleport(positionX,positionY,halfwidth,halfheight,userdata,rotation):b2Body{					var teleportBodyDef:b2BodyDef = new b2BodyDef();										teleportBodyDef.position.Set(positionX,positionY); //position of the body					teleportBodyDef.angle = rotation*Math.PI/180; //rotation of the body					teleportBodyDef.type = b2Body.b2_staticBody; //determines the body type						var teleportBody:b2Body = world.CreateBody(teleportBodyDef); //adds the body to the world					//shape					var teleportShape:b2PolygonShape = new b2PolygonShape(); //box shape 					teleportShape.SetAsBox(halfwidth,halfheight); //halfwidth,halfheight of the brick					//fixture 					var teleportFixtureDef:b2FixtureDef = new b2FixtureDef();					teleportFixtureDef.shape = teleportShape;					teleportFixtureDef.isSensor = true; //sensor shape					teleportBody.SetUserData(userdata);					teleportBody.CreateFixture(teleportFixtureDef); //assign fixture definition to the body					return teleportBody;				}			}														//////////////////////////////////////////////////////			// SKINS			//////////////////////////////////////////////////////			if (simulation_bol == false){				//GRASS							if (grass_bol == true){					var grassSkin:MovieClip = new grass(); //draw the balls (by using the symbols created in flash)					addChild(grassSkin); 													grassSkin.x = grassBody.GetPosition().x*SCALE;					grassSkin.y = grassBody.GetPosition().y*SCALE;				}				//TELEPORT				if (teleport_bol == true){					var teleportSkin:MovieClip = new teleport(); //draw the balls (by using the symbols created in flash)					addChild(teleportSkin); 													teleportSkin.x = teleportBody.GetPosition().x*SCALE;					teleportSkin.y = teleportBody.GetPosition().y*SCALE;					teleportSkin.rotation = teleportRotation;										//EXIT 								var exitSkin:MovieClip = new teleport_exit();					addChild(exitSkin); 					exitSkin.x = exitX;								exitSkin.y = exitY;					if (teleportActive_bol == false){						teleportSkin.gotoAndStop("off");						exitSkin.gotoAndStop("off");					}				}													//BRICK				if (brick_bol == true){					var brickSkin:MovieClip = new brick(); //draw the balls (by using the symbols created in flash)					addChild(brickSkin); 													brickSkin.x = brickBody.GetPosition().x*SCALE;					brickSkin.y = brickBody.GetPosition().y*SCALE;					brickSkin.rotation = brickRotation;								}				// //BALLS				// function attachSkin(clip, body):MovieClip{				// 	var skin:MovieClip = clip;				// 	skin.x = body.GetPosition().x*SCALE;				// 	skin.y = body.GetPosition().y*SCALE;				// 	addChild(skin);				// 	return skin;				// }								//draw the balls (by using the symbols created in flash)				var ball1Skin:MovieClip = new redball();  				addChild(ball1Skin); //problem: adds it to the stage very briefly				ball1Skin.visible = false;								var ball2Skin:MovieClip = new greyball();  				addChild(ball2Skin);				ball2Skin.visible = false;				function drawBalls():void{					ball1Skin.x = ball1Body.GetPosition().x*SCALE;					ball1Skin.y = ball1Body.GetPosition().y*SCALE;					ball1Skin.visible = true;										ball2Skin.x = ball2Body.GetPosition().x*SCALE;					ball2Skin.y = ball2Body.GetPosition().y*SCALE;					ball2Skin.visible = true;				}			}									//////////////////////////////////////////////////////			// CONTACT LISTENERS			//////////////////////////////////////////////////////									var collisionBallsStart:int = 0;									var collisionGrassStart:int = 0;			var collisionGrassEnd:int = 0;						var collisionTeleportStart:int = 0;					var collisionWallStart:int = 0;			var collisionBrickStart:int = 0;						//contact listener includes balls, grass, teleport			var contactRecorder = new custom_complex_contact_listener();					world.SetContactListener(contactRecorder);						var ball1linx:Number;			var ball1liny:Number;			var ball1Noiselinx:Number;			var ball1Noiseliny:Number;			var removeBallA_bol:Boolean;			var initialCollisionGrass:int = 0; //used to only apply velocity noise at initial contact with the grass 			//////////////////////////////////////////////////////			// UPDATE FUNCTION			//////////////////////////////////////////////////////						timer = startClip;			addEventListener(Event.ENTER_FRAME, update);								function update(e:Event):void{											outerLoop: for (var i:Number = 0; i < ffRate;	i++){										var timeStep:Number = 1/45; 					//We must update the world at every frame. 					//We can do it with Step function. Step has two parameters: the first is the time interval, in seconds. 					//It means at every frame I am going to update the world as if 1/45s passed					var velocityIterations:int = 2;					var positionIterations:int = 2;											//apply noise only after the collision of the balls 					if (timer >= collision_ary[flashPattern-1]){						if (grass_bol == true){							//GRASS							collisionGrassStart = contactRecorder.getCollisionGrassStart();							collisionGrassEnd = contactRecorder.getCollisionGrassEnd();																				// doesn't correspond to actual clip that participants saw [not sure what the difference is ...]							if (collisionGrassStart == 1 && collisionGrassEnd == 0 && initialCollisionGrass == 0){								initialCollisionGrass = 1;								// ball1Body.SetLinearDamping(.92)//damping of the grass 								// trace("grass collision");								// ball1Body.SetLinearDamping(.92)								applyNoise(0,velocityNoise)														}							else if (collisionGrassStart == 1 && collisionGrassEnd == 1){								// ball1Body.SetLinearDamping(0.02)								initialCollisionGrass = 0;								contactRecorder.setCollisionGrassStart();								contactRecorder.setCollisionGrassEnd();							}						}						//TELEPORTER 												if (teleportActive_bol == true){																collisionTeleportStart = contactRecorder.getCollisionTeleportStart();														 							if (collisionTeleportStart == 1){											// trace("teleport collision");								ball1Body.SetPosition(new b2Vec2(exitX/SCALE,exitY/SCALE));								var ball_velocity:b2Vec2 = ball1Body.GetLinearVelocity();								ball1Body.SetLinearVelocity(new b2Vec2(ball_velocity.x*0.4,ball_velocity.y*0.4));																						//if (simulation_bol == true){applyNoise(angularNoise,0.1)};	//uncomment to add teleporter noise 																						collisionTeleportStart = contactRecorder.setCollisionTeleportStart(); //reset collision detector							}						}												//BALLS						collisionBallsStart = contactRecorder.getCollisionBallsStart();								if (collisionBallsStart == 1){							// trace("ball collision");													//trace(timer);													// if (simulation_bol == true){applyNoise(angularNoise,velocityNoise)};							applyNoise(angularNoise,velocityNoise);														collisionBallsStart = contactRecorder.setCollisionBallsStart();						}						//WALLS 						collisionWallStart = contactRecorder.getCollisionWallStart();						if (collisionWallStart == 1){							// trace("wall collision");													//if (simulation_bol == true){applyNoise(angularNoise,0)}; //uncomment to add wall noise						}												if (brick_bol == true){							//BRICK							collisionBrickStart = contactRecorder.getCollisionBrickStart();							if (collisionBrickStart == 1){								// if (simulation_bol == true){applyNoise(angularNoise,0)}; //uncomment to add brick noise 																													}						}						//COUNTERFACTUAL COLLISION 						if (timer == collision_ary[flashPattern-1]){							if (condition == 2){								// trace("counterfactual collision");								// if (simulation_bol == true){applyNoise(angularNoise,velocityNoise)};								applyNoise(angularNoise,velocityNoise); 							}						}						}						function applyNoise(angularNoise,velocityNoise){																			// trace("ball1linx: ",ball1linx,"ball1liny: ",ball1liny,"angularNoise: ",angularNoise,"velocityNoise:", velocityNoise);											if (angularNoise != 0){							ball1linx = ball1Body.GetLinearVelocity().x;							ball1liny = ball1Body.GetLinearVelocity().y;							//number from random normal distribution							var randn:RandomNormal = new RandomNormal();														var angularPerturbation:Number;														if( fixedNoise_bol == true )							{								angularPerturbation = angularNoise;							}							else{								angularPerturbation = angularNoise*randn.standardNormal();							}							var cos_distortion:Number = Math.cos(angularPerturbation * (Math.PI/180)); //in degrees: degrees = radians * 180/Math.PI							var sin_distortion:Number = Math.sin(angularPerturbation * (Math.PI/180));														//change the direction of the velocity vector 							ball1Noiselinx = ball1linx * cos_distortion - ball1liny * sin_distortion;							ball1Noiseliny = ball1linx * sin_distortion + ball1liny * cos_distortion;														//apply noise														ball1Body.SetLinearVelocity(new b2Vec2(ball1Noiselinx,ball1Noiseliny));						}												if (velocityNoise != 0){							ball1linx = ball1Body.GetLinearVelocity().x;							ball1liny = ball1Body.GetLinearVelocity().y;							var randm:RandomNormal = new RandomNormal();							var velocityPerturbation:Number;							if( fixedNoise_bol == true )							{								velocityPerturbation = 1 + velocityNoise;							}							else{								velocityPerturbation = 1 + randm.standardNormal()*velocityNoise;							}							ball1Noiselinx = ball1linx * velocityPerturbation;							ball1Noiseliny = ball1liny * velocityPerturbation;								//apply noise 														ball1Body.SetLinearVelocity(new b2Vec2(ball1Noiselinx,ball1Noiseliny));						}															//remove gray ball 																		// if (collisionBallsStart == 1){													// 	//world.DestroyBody(ball2Body);						// }														//reset collision detectors 						collisionBallsStart = contactRecorder.setCollisionBallsStart();						collisionWallStart = contactRecorder.setCollisionWallStart();						collisionBrickStart = contactRecorder.setCollisionBrickStart();					}													if (simulation_bol == false){drawBalls();}//draws the balls (updates the positions of the movieclips)											// drawBalls();															world.Step(timeStep,velocityIterations,positionIterations);					world.ClearForces();					timer = timer + 1; //updates the timer				//checks when to stop 				if (timer == stopClip){					if (saveData_bol == true){												if (ball1Body.GetDefinition().position.x < 0){							goalReached = 1;						}							data.push(goalReached);					}					//stops the world															removeEventListener(Event.ENTER_FRAME, update);					if (simulation_bol == true){							counter = counter + 1; 														dispatchEvent(new Event("SimulationRoundFinished"));																			}					else{						dispatchEvent(new Event("clipFinished"));							}					break outerLoop; 																		}			}		}	}					function SaveData(event:Event){					if (counter < nSimulations){											// data.push(flashPattern,goalReached,angularNoise*randomtest,collision[flashPattern-1]); //only saves whether red ball reached the goal or not								goalReached = 0;				// timer = 0; //resets the timer				//trace('Run: ', String(run),'Pattern: ', String(flashPattern),'Simulation round: ', String(counter)); 								dispatchEvent(new Event("NewRound"));			}						else if (counter == nSimulations && flashPattern < maxPattern){				timer = 0; //resets the timer												counter = 0;				goalReached = 0;				flashPattern = flashPattern + 1;									trace('Run: ', String(run), 'Pattern: ', String(flashPattern)); 															dispatchEvent(new Event("NewRound"));				}						else if (counter == nSimulations && flashPattern == maxPattern && run < maxRun) {					timer = 0; //resets the timer									counter = 0;				goalReached = 0;				flashPattern = 1;								run = run + 1;				// trace('Goal reached: ', goalReached);								switch( run )				{					case 2 :						condition = 2; 										teleport_bol = true;						brick_bol = true;						grass_bol = false;							break;					// case 3 :					// 	condition = 2; 									// 	teleport_bol = false;					// 	brick_bol = true;					// 	grass_bol = true;							// break;					// case 2 :					// 	condition = 1; 									// 	teleport_bol = false;					// 	brick_bol = true;					// 	grass_bol = true;							// break;					// case 3 :					// 	condition = 1; 									// 	teleport_bol = true;					// 	brick_bol = false;					// 	grass_bol = true;							// break;					// case 4 :					// 	condition = 1; 									// 	teleport_bol = true;					// 	brick_bol = true;					// 	grass_bol = false;							// break;					// case 5 :					// 	condition = 2; 									// 	teleport_bol = true;					// 	brick_bol = true;					// 	grass_bol = true;							// break;					// case 6 :					// 	condition = 2; 									// 	teleport_bol = false;					// 	brick_bol = true;					// 	grass_bol = true;							// break;					// case 7 :					// 	condition = 2; 									// 	teleport_bol = true;					// 	brick_bol = false;					// 	grass_bol = true;							// break;					// case 8 :					// 	condition = 2; 									// 	teleport_bol = true;					// 	brick_bol = true;					// 	grass_bol = false;							// break;				}				dispatchEvent(new Event("NewRound"));			}			else if (counter == nSimulations && flashPattern == maxPattern && run == maxRun) {																	// trace('Goal reached: ', goalReached);				var fileRef:FileReference= new FileReference();				var filename_str:String;				filename_str = "teleport_angularNoise_" + angularNoise + ".txt";					// filename_str = "test1.txt";					fileRef.save([data] , filename_str);			}										}	}	}}
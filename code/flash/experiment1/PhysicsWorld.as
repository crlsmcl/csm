package{	import Box2D.Collision.Shapes.b2CircleShape;	import Box2D.Collision.Shapes.b2PolygonShape;	import Box2D.Common.Math.b2Vec2;	import Box2D.Dynamics.b2Body;	import Box2D.Dynamics.b2BodyDef;	import Box2D.Dynamics.b2ContactListener;	import Box2D.Dynamics.b2DebugDraw;	import Box2D.Dynamics.b2Fixture;	import Box2D.Dynamics.b2FixtureDef;	import Box2D.Dynamics.b2World;	import flash.utils.getTimer;	import flash.display.MovieClip;	import flash.display.Sprite;	import flash.events.Event;	import flash.net.*; //needed for accessing and saving data		public class PhysicsWorld extends Sprite	{//		public var timer:int = 0;		//public var pattern:uint = 5;//		public var condition:uint = 1; //1 = actual, 2 = counterfactual				//public var noise:Boolean = false;//		public var noise:Boolean = true;		public var noiseStrength:Number = 1;				public var body1posx:Number;		public var body1posy:Number;		public var body1linx:Number;		public var body1liny:Number;				public var body2posx:Number; 		public var body2posy:Number;		public var body2linx:Number;		public var body2liny:Number;		public var saveData_bol:Boolean = false;		// public var saveData_bol:Boolean = true;		public var ballPositions:Array = []; 					// public function PhysicsWorld(flashPattern:uint, condition:uint, collision:Number, startClip:Number, stopClip:Number, noise:Boolean, posVel:Array) 		public function PhysicsWorld(flashPattern:uint, condition:uint, collision:Number, startClip:Number, stopClip:Number, noise:Boolean) 		{					 									 					//Scaling constant 			var SCALE:Number = 60; //--> pixel to meter 			var SCALE_big:Number = 75; //for the 1000x750 dimension screen			var WIDTH:Number = 800;			var HEIGHT:Number = 600;			var speed:Number = 2;			// stopClip = 400;						//Creating the world			var gravity:b2Vec2 = new b2Vec2(0,0); //x and y coordinate			var allowSleep:Boolean = false; 			var world:b2World = new b2World(gravity,allowSleep);						//////////////////////////////////////////////////////			// Create Objects				//////////////////////////////////////////////////////						//Creating Objects in the world  			//1. Body definition			//2. Body			//3. Shape 			//4. Fixture definition 			//5. Create fixture 						//Walls						var topWallBody:b2Body = createWalls((WIDTH/2)/SCALE,10/SCALE, (WIDTH/2)/SCALE,(20/2)/SCALE,"topWall");			var bottomWallBody:b2Body = createWalls((WIDTH/2)/SCALE,590/SCALE, (WIDTH/2)/SCALE,(20/2)/SCALE,"bottomWall");			var topLeftWallBody:b2Body = createWalls(10/SCALE,100/SCALE, 10/SCALE,100/SCALE,"topLeftWall");			var bottomLeftWallBody:b2Body = createWalls(10/SCALE,(HEIGHT-100)/SCALE, 10/SCALE,100/SCALE,"bottomLeftWall");						function createWalls(positionX,positionY,halfwidth,halfheight,userdata):b2Body{				//def				var wallBodyDef:b2BodyDef = new b2BodyDef();				wallBodyDef.position.Set(positionX,positionY); //position of the body				wallBodyDef.type = b2Body.b2_staticBody; //determines the body type					var wallBody:b2Body = world.CreateBody(wallBodyDef); //adds the body to the world				//shape				var wallShape:b2PolygonShape = new b2PolygonShape(); //box shape 				wallShape.SetAsBox(halfwidth,halfheight);				//fixture 				var wallFixtureDef:b2FixtureDef = new b2FixtureDef();				wallFixtureDef.shape = wallShape;				wallFixtureDef.density = 1;				wallFixtureDef.friction = 0;				wallFixtureDef.restitution = 1;				wallBody.SetUserData(userdata);				wallBody.CreateFixture(wallFixtureDef); //assign fixture definition to the body				return wallBody;			}									trace("width", WIDTH, "height", HEIGHT, "scale", SCALE)					//Balls						//assigns array to position and velocities of the balls 			// body1posx = posVel[0];			// body1posy = posVel[1];			// body1linx = posVel[2];			// body1liny = posVel[3];						// body2posx = posVel[4];			// body2posy = posVel[5];			// body2linx = posVel[6];			// body2liny = posVel[7];			// for(var i:int = 1; i < 21; i++) {			switch (flashPattern){			case 1:				body1posx = (WIDTH+29)/SCALE				body1posy = (500)/SCALE				body1linx = speed*-1				body1liny = speed*-.5				body2posx = (WIDTH + 30)/SCALE				body2posy = (50)/SCALE				body2linx = speed*-1				body2liny = speed*.6				break;			case 2:				body1posx = (WIDTH+30)/SCALE				body1posy = (150)/SCALE				body1linx = speed*-1				body1liny = speed*0				body2posx = (WIDTH + 30)/SCALE				body2posy = (400)/SCALE				body2linx = speed*-1				body2liny = speed*-0.4				break;			case 3:				body1posx = (WIDTH+30)/SCALE				body1posy = (420)/SCALE				body1linx = speed*-1				body1liny = speed*-0.25				body2posx = (WIDTH + 30)/SCALE				body2posy = (50)/SCALE				body2linx = speed*-1				body2liny = speed*0.5				break;			case 4:				body1posx = (WIDTH+30)/SCALE				body1posy = (175)/SCALE				body1linx = speed*-1				body1liny = speed*0.25				body2posx = (WIDTH + 30)/SCALE				body2posy = (550)/SCALE				body2linx = speed*-1				body2liny = speed*-0.5				break;			case 5:				body1posx = (WIDTH+30)/SCALE				body1posy = (300)/SCALE				body1linx = speed*-1				body1liny = speed*0				body2posx = (WIDTH + 30)/SCALE				body2posy = (50)/SCALE				body2linx = speed*-1				body2liny = speed*0.5				break;			case 6:				body1posx = (WIDTH+30)/SCALE				body1posy = (250)/SCALE				body1linx = speed*-1				body1liny = speed*-0.55				body2posx = (WIDTH + 50)/SCALE				body2posy = (490)/SCALE				body2linx = speed*-1				body2liny = speed*-0.5				break;			case 7:				body1posx = (WIDTH+30)/SCALE				body1posy = (150)/SCALE				body1linx = speed*-1				body1liny = speed*0.45				body2posx = (WIDTH + 40)/SCALE				body2posy = (500)/SCALE				body2linx = speed*-1				body2liny = speed*-0.3				break;			case 8:				body1posx = (WIDTH+30)/SCALE				body1posy = (450)/SCALE				body1linx = speed*-1				body1liny = speed*-0.45				body2posx = (WIDTH + 42)/SCALE				body2posy = (100)/SCALE				body2linx = speed*-1				body2liny = speed*0.3				break;			case 9:				body1posx = (WIDTH+30)/SCALE				body1posy = (100)/SCALE				body1linx = speed*-1				body1liny = speed*0.34				body2posx = (WIDTH + 45)/SCALE				body2posy = (490)/SCALE				body2linx = speed*-1				body2liny = speed*-0.3				break;			case 10:				body1posx = (WIDTH+30)/SCALE				body1posy = (500)/SCALE				body1linx = speed*-1				body1liny = speed*-0.36				body2posx = (WIDTH + 50)/SCALE				body2posy = (110)/SCALE				body2linx = speed*-1				body2liny = speed*0.3				break;			case 11:				body1posx = (WIDTH+30)/SCALE				body1posy = (350)/SCALE				body1linx = speed*-1				body1liny = speed*0				body2posx = (WIDTH + 50)/SCALE				body2posy = (550)/SCALE				body2linx = speed*-1				body2liny = speed*-0.4				break;			case 12:				body1posx = (WIDTH+30)/SCALE				body1posy = (250)/SCALE				body1linx = speed*-1				body1liny = speed*0				body2posx = (WIDTH + 57)/SCALE				body2posy = (50)/SCALE				body2linx = speed*-1				body2liny = speed*0.41				break;			case 13:				body1posx = (WIDTH+30)/SCALE				body1posy = (500)/SCALE				body1linx = speed*-1				body1liny = speed*-.5				body2posx = (WIDTH + 40)/SCALE				body2posy = (200)/SCALE				body2linx = speed*-1				body2liny = speed*0.05				break;			case 14:				body1posx = (WIDTH+30)/SCALE				body1posy = (125)/SCALE				body1linx = speed*-1				body1liny = speed*0				body2posx = (WIDTH + 45)/SCALE				body2posy = (375)/SCALE				body2linx = speed*-1				body2liny = speed*-0.7				break;			case 15:				body1posx = (WIDTH+30)/SCALE				body1posy = (500)/SCALE				body1linx = speed*-1				body1liny = speed*-0.34				body2posx = (WIDTH + 50)/SCALE				body2posy = (200)/SCALE				body2linx = speed*-1				body2liny = speed*0.1				break;			case 16:				body1posx = (WIDTH+30)/SCALE				body1posy = (100)/SCALE				body1linx = speed*-1				body1liny = speed*0.36				body2posx = (WIDTH + 50)/SCALE				body2posy = (400)/SCALE				body2linx = speed*-1				body2liny = speed*-0.1				break;			case 17:				body1posx = (WIDTH+30)/SCALE				body1posy = (200)/SCALE				body1linx = speed*-1				body1liny = speed*0.12				body2posx = (WIDTH + 50)/SCALE				body2posy = (450)/SCALE				body2linx = speed*-1				body2liny = speed*-0.2				break;			case 18:				body1posx = (WIDTH+30)/SCALE				body1posy = (300)/SCALE				body1linx = speed*-0.8				body1liny = speed*0				body2posx = (WIDTH + 300)/SCALE				body2posy = (300)/SCALE				body2linx = speed*-1.2				body2liny = speed*0				break;			//additional clips 			case 19:				body1posx = (WIDTH+30)/SCALE				body1posy = (500)/SCALE				body1linx = speed*-1				body1liny = speed*-.5				body2posx = (WIDTH + 60)/SCALE				body2posy = (130)/SCALE				body2linx = speed*-1				body2liny = speed*0.3				break;			case 20:				body1posx = (WIDTH+30)/SCALE				body1posy = (300)/SCALE				body1linx = speed*-1				body1liny = speed*0				body2posx = (WIDTH+30)/SCALE				body2posy = (100)/SCALE				body2linx = speed*-1				body2liny = speed*0.4				break;			//additional clips not used in the original experiment: 			}						//get rid of grey ball for counterfactual cases			if (condition == 2){				body2posx = 1000;				body2posy = 1000;				body2linx = 0;				body2liny = 0;			} else if (condition ==3){				body1posx = 1000;				body1posy = 1000;				body1linx = 0;				body1liny = 0;			}else if (condition ==4){							}						//create the balls			var ball1Body:b2Body = createBalls(body1posx,body1posy, 1, new b2Vec2(body1linx,body1liny), 0,"redBall",b2Body.b2_dynamicBody);			var ball2Body:b2Body = createBalls(body2posx,body2posy, 1, new b2Vec2(body2linx,body2liny), 0,"greyBall",b2Body.b2_dynamicBody);						function createBalls(positionX,positionY,density,linearVel,linearDamp,userdata,type):b2Body{				//def				var ballBodyDef:b2BodyDef= new b2BodyDef();				ballBodyDef.position.Set(positionX,positionY); //position of the body				ballBodyDef.type = type; //determines the body type				ballBodyDef.bullet = true; //prevents tunelling for fast moving objects				ballBodyDef.linearVelocity = linearVel; //velocity in x and y direction (x:positive --> right, y:positive --> down)				ballBodyDef.linearDamping = linearDamp; //linear damping 				//body				var ballBody:b2Body = world.CreateBody(ballBodyDef); //adds the body to the world				//shape				var ballShape:b2CircleShape = new b2CircleShape(.5); //radius of the circle (.5 m)				//fixture 				var ballFixtureDef:b2FixtureDef = new b2FixtureDef();				ballFixtureDef.shape = ballShape;				ballFixtureDef.density = density;				ballFixtureDef.friction = 0;				ballFixtureDef.restitution = 1;								ballBody.SetUserData(userdata);				ballBody.CreateFixture(ballFixtureDef); //assign fixture definition to the body								return ballBody;			}									//////////////////////////////////////////////////////			// CONTACT LISTENERS			//////////////////////////////////////////////////////						if (saveData_bol == true){				var collisionStart:int = 0;				var collisionEnd:int = 0;								var contactRecorder = new custom_contact_listener();						world.SetContactListener(contactRecorder);			}									//////////////////////////////////////////////////////			// DRAWING				//////////////////////////////////////////////////////									//attach skins to bodies 			function attachSkin(clip, body):MovieClip{				var skin:MovieClip = clip;				skin.x = body.GetPosition().x*SCALE;				skin.y = body.GetPosition().y*SCALE;				addChild(skin);				return skin;			}								//draw the balls (by using the symbols created in flash)			var ball1Skin:MovieClip = new redball();  			addChild(ball1Skin); //problem: adds it to the stage very briefly			ball1Skin.visible = false;						var ball2Skin:MovieClip = new greyball();  			addChild(ball2Skin);			ball2Skin.visible = false;						function drawBalls():void{					ball1Skin.x = ball1Body.GetPosition().x*SCALE;					ball1Skin.y = ball1Body.GetPosition().y*SCALE;					//ball1Skin.rotation = ball1Body.GetAngle()*(180/Math.PI);					ball1Skin.visible = true;										ball2Skin.x = ball2Body.GetPosition().x*SCALE;					ball2Skin.y = ball2Body.GetPosition().y*SCALE;					//ball2Skin.rotation = ball2Body.GetAngle()*(180/Math.PI);					ball2Skin.visible = true;			}									addEventListener(Event.ENTER_FRAME, update);						var frames:int=0;			var prevTimer:Number=0;			var curTimer:Number=0;									//number from random normal distribution			var randn:RandomNormal = new RandomNormal();									if (saveData_bol == true){				//checks whether the red ball went through the goal or not 				var goalCriterion:Number; 					var goalReached:int = 0; 				//used to save the data				var data:Array = new Array();			}						//////////////////////////////////////////////////////			// UPDATE FUNCTION			//////////////////////////////////////////////////////						var timer:int = startClip;						function update(e:Event):void{				var timeStep:Number = 1 /30;				//We must update the world at every frame. 				//We can do it with Step function. Step has two parameters: the first is the time interval, in seconds. 				//It means at every frame I am going to update the world as if 1/30s passed				var velocityIterations:int = 10;				var positionIterations:int = 10;											if (saveData_bol == true){				//checks whether the red ball has passed the goal				if (ball1Body.GetDefinition().position.x < 0){					goalReached = 1;				}								//checks whether the two balls have collided					// collisionStart = contactRecorder.getCollisionStart();				// collisionEnd = contactRecorder.getCollisionEnd();				//updates the data structure				// data.push(ball1Body.GetDefinition().position.x/SCALE, ball1Body.GetDefinition().position.y/SCALE, 				// 	ball1Body.GetDefinition().linearVelocity.x, ball1Body.GetDefinition().linearVelocity.y, 				// 	ball2Body.GetDefinition().position.x/SCALE, ball2Body.GetDefinition().position.y/SCALE, 				// 	ball2Body.GetDefinition().linearVelocity.x, ball2Body.GetDefinition().linearVelocity.y,				// 	collisionStart, collisionEnd, goalReached);				ballPositions.push(								"clip", flashPattern, 				"timer", timer+1,				"ballA.x", ball2Body.GetPosition().x*SCALE_big,				"ballA.y", ball2Body.GetPosition().y*SCALE_big,				"ballB.x", ball1Body.GetPosition().x*SCALE_big,				"ballB.y", ball1Body.GetPosition().y*SCALE_big				)				}												world.Step(timeStep,velocityIterations,positionIterations);				world.ClearForces();												if (timer == collision){					//introduces noise on the velocities 					if (noise == true){						var ball1NoiseLinX = ball1Body.GetDefinition().linearVelocity.x +  noiseStrength * randn.standardNormal();						var ball1NoiseLinY = ball1Body.GetDefinition().linearVelocity.y +  noiseStrength * randn.standardNormal();												var ball2NoiseLinX = ball2Body.GetDefinition().linearVelocity.x +  noiseStrength * randn.standardNormal();						var ball2NoiseLinY = ball2Body.GetDefinition().linearVelocity.y +  noiseStrength * randn.standardNormal();										//define noisy version of the balls: noise only for velocity												world.DestroyBody(ball1Body);						world.DestroyBody(ball2Body);						ball1Body = createBalls(ball1Body.GetDefinition().position.x,ball1Body.GetDefinition().position.y, 1, 							new b2Vec2(ball1NoiseLinX,ball1NoiseLinY), 0,"redBall", b2Body.b2_dynamicBody);						ball2Body = createBalls(ball2Body.GetDefinition().position.x,ball2Body.GetDefinition().position.y, 1, 							new b2Vec2(ball2NoiseLinX,ball2NoiseLinY), 0,"greyBall", b2Body.b2_dynamicBody);					}									}																//trace(data)				drawBalls(); //draws the balls (updates the positions of the movieclips										timer = timer + 1; //updates the timer								//checks when to stop 				if (timer >= stopClip){					//stops the world					removeEventListener(Event.ENTER_FRAME, update);					dispatchEvent(new Event("clipFinished"));										if (saveData_bol == true){						//saves data locally 						var fileRef:FileReference= new FileReference();						//var filename_str:String = "~/Documents/Dropbox/work/Matlab/MIT/actual" + pattern + ".txt"; //doesn't work						var filename_str:String = "actual_ballPositions_" + flashPattern + ".txt";						if (condition == 2){							filename_str = "counterfactual_ballPositions_" + flashPattern + ".txt";						}						// fileRef.save([data] , filename_str);						fileRef.save([ballPositions] , filename_str);					}				}							}					}	// } 	}}